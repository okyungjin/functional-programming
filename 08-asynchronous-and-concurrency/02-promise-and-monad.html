<script src="../lib/fx.js"></script>

## Composition
<script>
  /**
   * 함수 합성 관점에서의 Promise
   * Promise는 비동기 상황에서 함수 합성을 안전하게 하기 위한 도구라고 볼 수 있다.
   * 비동기 값을 가지고 연속적인 함수 합성을 안전하게 하는 모나드라고 설명할 수 있다.
   * 모나드에 대해 설명하려면 함수 합성에 대해 간단하게 알아야 한다.
   */

  // f . g
  // f(g(x))
  // 이런 함수 합성이 안전하도록 하는 것이 모나드이고, 비동기 상황에서 사용되는 것이 Promise이다.

  /**
   * 자바스크립트는 동적 타입 언어라서 모나드나 대수 구조의 타입 등이 묻어나지 않는 경향이 있다.
   * 자바스크립트에서는 모나드를 직접 만들거나 사용자 정의 객체를 만들거나 하면서 프로그래밍하진 않는다.
   * 모나드를 알고 있으면 함수형 프로그래밍에서 사고나 응용력에 도움이 될 수 있기 때문에 알아두면 좋다.
   * 자바스크립트에서는 Array, Promise를 통해 모나드에 대해 알 수 있으며, 함수 합성에서의 안정성 등을 살펴볼 수 있다.
   */

  const g = a => a + 1;
  const f = a => a * a;

  log(f(g(1))); // 4

  /**
   * 아래의 함수 합성은 안전하다고 볼 수 없다.
   * 유효하지 않은 인자가 들어왔을 때 값이 흘러서 NaN이 콘솔에 찍히기 때문이다.
   * 어떠한 값이 들어올지 모르는 현실 상황에서 어떻게 합수 합성을 안전하게 할 수 있을까?
   * 그런 아이디어가 모나드이다.
   */
  log(f(g())); // NaN


  Array.of(1).map(g).map(f).forEach(r => log(r));
  /**
   * 그럼 이렇게 작성했을 때의 이점은 무엇인가?
   * 아래와 같이 배열이 비어있을 경우 아무것도 출력하지 않는다.
   * 죽 `log`를 실행하지 않는다는 것이다.
   * 이것은 함수 합성을 안전하게 하는 것이다!
   */
  [].map(g).map(f).forEach(r => log(r));

  // 그럼 Promise는 어떤 함수를 합성하는데?
  Promise.resolve(2).then(g).then(f).then(r => log(r));

  new Promise(resolve => setTimeout(() => resolve(2), 100)
  ).then(g).then(f).then(r => log(r));

  /**
   * Promise는 위의 배열 예시와 같이 값이 있거나 없거나에 대한 안전한 함수 합성을 하려는 것이 아니고,
   * 비동기 상황에서의 합성을 안전하게 하려는 성질을 가지고 있다.
   * delay가 있는 상황에서도 적절한 시점에 함수를 합성할 수 있도록 하는 도구가 Promise이다.
   */
</script>
