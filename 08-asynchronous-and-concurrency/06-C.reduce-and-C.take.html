<script src="../lib/fx.js"></script>

## 지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take
- 한 번에 실행하는 것이 부하가 아니라 효율인 상황에서 사용하면 좋다.
<script>
  const C = {};
  C.reduce = curry((f, acc, iter) => {
    const iter2 = iter ? [...iter] : [...acc];
    iter2.forEach(a => a.catch(function() {}));
    return iter
      ? reduce(f, acc, [...iter])
      : reduce(f, [...acc])
  });

  // reduce를 하지 않았을 때 delay500에 함수가 들어오는지 확인
  const delay1000 = a => new Promise(resolve => {
    log('heavy io');
    setTimeout(() => resolve(a), 1000);
  });

  // reduce를 하지 않으면 함수들을 대기해 놓은 상태이다. delay1000 내부는 아직 실행되지 않는다.
  console.time('');
  go([1, 2, 3, 4, 5],
    L.map(a => delay1000(a * a)),
    L.filter(a => a % 2),
    reduce(add),
    log,
    _ => console.timeEnd(''));

  console.time('C');
  go([1, 2, 3, 4, 5],
    L.map(a => delay1000(a * a)),
    L.filter(a => a % 2),
    C.reduce(add),
    log,
    _ => console.timeEnd('C'));
</script>